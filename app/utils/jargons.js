const jargons = {
  'Arity': 'The number of arguments a function takes. From words like unary, binary, ternary, etc. This word has the distinction of being composed of two suffixes, "-ary" and "-ity." Addition, for example, takes two arguments, and so it is defined as a binary function or a function with an arity of two. Such a function may sometimes be called "dyadic" by people who prefer Greek roots to Latin. Likewise, a function that takes a variable number of arguments is called "variadic," whereas a binary function must be given two and only two arguments, currying and partial application notwithstanding (see below).',
  'Higher-Order Functions (HOF)': 'A function which takes a function as an argument and/or returns a function.',
  'Partial Application': 'Partially applying a function means creating a new function by pre-filling some of the arguments to the original function.',
  'Currying': 'The process of converting a function that takes multiple arguments into a function that takes them one at a time. Each time the function is called it only accepts one argument and returns a function that takes one argument until all arguments are passed.',
  'Function Composition': 'The act of putting two functions together to form a third function where the output of one function is the input of the other.',
  'Purity': 'A function is pure if the return value is only determined by its input values, and does not produce side effects.',
  'Side effects': 'A function or expression is said to have a side effect if apart from returning a value, it interacts with (reads from or writes to) external mutable state.',
  'Idempotent': 'A function is idempotent if reapplying it to its result does not produce a different result.',
  'Point-Free Style': 'Writing functions where the definition does not explicitly identify the arguments used. This style usually requires currying or other Higher-Order functions. A.K.A Tacit programming.',
  'Predicate': 'A predicate is a function that returns true or false for a given value. A common use of a predicate is as the callback for array filter.',
  'Categories': 'Objects with associated functions that adhere to certain rules. E.g. Monoid',
  'Value': 'Anything that can be assigned to a variable.',
  'Constant': 'A variable that cannot be reassigned once defined.',
  'Functor': 'An object that implements a map function which, while running over each value in the object to produce a new object, adheres to two rules',
  'Pointed Functor': 'An object with an of function that puts any single value into it. ES2015 adds Array.of making arrays a pointed functor.',
  'Lift': 'Lifting is when you take a value and put it into an object like a functor. If you lift a function into an Applicative Functor then you can make it work on values that are also in that functor. Some implementations have a function called lift, or liftA2 to make it easier to run functions on functors.',
  'Referential Transparency': 'An expression that can be replaced with its value without changing the behavior of the program is said to be referentially transparent.',
  'Equational Reasoning': 'When an application is composed of expressions and devoid of side effects, truths about the system can be derived from the parts.',
  'Lambda': 'An anonymous function that can be treated like a value.',
  'Lambda Calculus': 'A branch of mathematics that uses functions to create a universal model of computation.',
  'Lazy evaluation': 'Lazy evaluation is a call-by-need evaluation mechanism that delays the evaluation of an expression until its value is needed. In functional languages, this allows for structures like infinite lists, which would not normally be available in an imperative language where the sequencing of commands is significant.',
  'Monoid': 'An object with a function that "combines" that object with another of the same type.',
  'Monad': 'A monad is an object with of and chain functions. chain is like map except it un-nests the resulting nested object.',
  'Comonad': 'An object that has extract and extend functions.',
  'Applicative Functor': 'An applicative functor is an object with an ap function. ap applies a function in the object to a value in another object of the same type.',
  'Morphism': 'A transformation function.',
  'Isomorphism': 'A pair of transformations between 2 types of objects that is structural in nature and no data is lost. For example, 2D coordinates could be stored as an array [2,3] or object {x: 2, y: 3}.',
  'Setoid': 'An object that has an equals function which can be used to compare other objects of the same type.',
  'Semigroup': 'An object that has a concat function that combines it with another object of the same type.',
  'Foldable': 'An object that has a reduce function that can transform that object into some other type.',
  'Type Signatures': 'Often functions in JavaScript will include comments that indicate the types of their arguments and return values.',
  'Union type': 'A union type is the combination of two types together into another one.',
  'Product type': 'A product type combines types together in a way you`re probably more familiar with: const point = (x, y) => ({x: x, y: y});',
  'Option': 'Option is a union type with two cases often called Some and None.',
};

export default jargons;
